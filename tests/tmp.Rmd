---
title: "triangles"
author: "pss"
date: "February 26, 2018"
output: html_document
params:
  data_dir: data
  expt: CFSgonogo
  model: "bivariate_probit_mixed_onec_mo_nonc"
  flag: "rep-5_rho-3_sub-10-20-30_radius-3-radian-3"
  reps: 1
  n_condition: 3
  condition_rho: !r seq(from = -0.75, to = 0.75, length.out = 3) 
  n_subject: !r c(10,20,30)
  n_item: 20
  type_model: !r c("mon", "nmon")
  radius: !r seq(from = 0, to = 1, length.out = 3)
  radian: !r seq(from = pi/6, to = pi/3, length.out = 3)
  subject_scale: !r sqrt(0.25)
  item_scale: !r sqrt(0.25) # sqrt to remind that model will produce standard deviation
  subject_rho: 0
  item_rho: 0
  chains: 6
  iter: 500
  warmup: 1000
  compile: 0
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, root.dir = devtools::package_file(), message = FALSE, warning = FALSE, fig.width = 7, fig.asp = 1, fig.path = paste0(file.path(devtools::package_file(), "output", "figures", params$model, params$flag), .Platform$file.sep) )

devtools::load_all()

dir.model <- file.path(dir.stan_samples, params$model)
if (!dir.exists(dir.model)){
  dir.create(dir.model)
}
dir.model_flag <- file.path(dir.model, params$flag)
if (!dir.exists(dir.model_flag)){
  dir.create(dir.model_flag)
}

options(mc.cores = params$chains)
rstan::rstan_options("auto_write" = TRUE)

if (params$compile){
  rstan::stan_model(file.path(devtools::package_file(), "stan", paste0(params$model, ".stan")))
}


```


```{r}

make_grand_d <- function(n_item, n_subject, condition_rho, radian_mid, radius_mid){
  
  d <- crossing(n_item, n_subject,
                condition_rho, radian_mid, radius_mid) %>%
    mutate(data = pmap(list(n_item=n_item, n_subject=n_subject, condition_rho=condition_rho, radian_mid=radian_mid,radius_mid=radius_mid),
                       gen_dataset))
  
}

apply_type <- function(d, model_type){
  d %<>% crossing(type = model_type) %>%
    mutate(data = map2(data, type, ~.x %>% mutate(type = .y)))
  
  return(d)
}

compose_stan_data <- function(d){
  d %<>% mutate(stan_data = map(data, gen_stan_data))
  return(d)
}


run_stan <- function(stan_data){
  pars <- c("theta_log", "theta_raw", "lps", "zeta_raw", "theta_raw","condition_mu_raw", "zeta",
            "Mu_unordered", "Mu_ordered",
            "subject_mu_raw", "item_mu_raw", "subject_mu",
            "subject_L", "item_L",
            "condition_omega")
  
  model <- stan_model(file.path(devtools::package_file(), "stan", paste0(params$model, ".stan")))

  post <- sampling(model,
                   data = stan_data,
                   iter = params$warmup + params$iter,
                   warmup = params$warmup,
                   chains = params$chains
                   , pars = pars
                   , include = FALSE
                   , init_r = 0.25
                   , control = list(adapt_delta = .99)
  )
  
  loaded_dlls = getLoadedDLLs()
  loaded_dlls = loaded_dlls[str_detect(names(loaded_dlls), '^file')]
  if (length(loaded_dlls) > 10) {
    for (dll in head(loaded_dlls, -10)) {
      message("Unloading DLL ", dll[['name']], ": ", dll[['path']])
      dyn.unload(dll[['path']])
    }
  }
  
  
  return(post)
}
```

```{r}


d <- make_grand_d(n_item = params$n_item, n_subject = params$n_subject, condition_rho = params$condition_rho, radian_mid = params$radian, radius_mid = params$radius)

```



```{r}

wf_data <- drake_plan(data = make_grand_d(n_item = params$n_item, n_subject = params$n_subject,
                                          condition_rho = params$condition_rho, radian_mid = params$radian, radius_mid = params$radius))

wf_data_typed <- drake_plan(data_model = apply_type(dataset__, model_type = params$type_model), strings_in_dots = "literals") %>%
  evaluate_plan(plan = ., rules = list(dataset__ = wf_data$target)) 

wf_stan_data <- drake_plan(stan_data = compose_stan_data(dataset__)) %>%
  plan_analyses(plan = ., datasets = wf_data_typed) 

```


```{r}

wf_stan <- drake_plan(post = run_stan(dataset__)) %>%
  plan_analyses(plan = ., datasets = wf_stan_data) 

```


```{r}

wf_plan <- rbind(wf_data, wf_data_typed, wf_stan_data)

con <- drake::drake_config(wf_plan)

make(wf_plan)

```


```{r, warning=FALSE, message=FALSE}

post <- readr::read_rds(path = file.path(devtools::package_file(), "output", "stan_samples", params$model, params$flag, glue::glue("d_fit.rds")))

# by default, files returned in alphabetical order. that might be okay, but when the post-{m} files were not
# 0-padded this created trouble for getting the samples in the correct order. Instead, we sort files by
# creationtime, given in column ctime
details <- file.info(list.files(path= file.path(devtools::package_file(), "output", "stan_samples", params$model, params$flag), pattern = "post-", full.names = TRUE)) %>%
  mutate(fname = rownames(.)) %>%
  as_tibble() %>%
  arrange(ctime)

pb <- txtProgressBar(min = 1, max = length(files), initial = 0, style = 3) 

log_lik <- vector(mode = "list", length = nrow(post))
w <- vector(mode = "list", length = nrow(post))
lpd <- vector(mode = "numeric", length = nrow(post))
log_lik_ind <- 1
for(f in 1:length(files)){
  post2 <- readr::read_rds(path = details[f,]$fname) 
  
  for(i in 1:length(post2)){
    log_lik[[log_lik_ind]] <- post2 %>%
      extract2(., i) %>%
      loo::extract_log_lik()
    
    # these values are here in case not complete (in purrr::map, loo would complain if sample not present)
    w[[log_lik_ind]] <- loo::waic(log_lik[[log_lik_ind]])
    lpd[log_lik_ind] <- w[[log_lik_ind]]$elpd_waic + w[[log_lik_ind]]$p_waic 
    log_lik_ind <- log_lik_ind + 1
  }
  
  setTxtProgressBar(pb,f)
}
post <- post %>%
  mutate(log_lik = log_lik) %>%
  mutate(waic = w) %>%
  mutate(lpd_waic = lpd)


```



```{r}

post %>%
  select(expt, radius_mid, radian_mid, condition_rho, lpd_waic, type_model) %>%
  spread(type_model, lpd_waic) %>%
  mutate(difference = nmon - mon) %>%
  # filter(difference < 2.5) %>%
  ggplot(aes(x=radian_mid, y = radius_mid, fill=difference, z = difference)) +
  geom_raster() +
  scale_fill_gradient2(low = scales::muted("blue"), high = scales::muted("red")) +
  # geom_contour(color = "white", aes(alpha = ..level..), size = 1, binwidth = .1) +
  facet_wrap( ~ condition_rho, labeller = "label_both")

```


```{r}

d <- gen_d(n_b = 100, n_theta = 8, n_r = 100, max_theta1 = 3 * (pi/2)) %>%
  mutate(condition = plyr::mapvalues(condition, 1:3 ,c("one","two","three"))) %>%
  gather(key = question, value = probit, c(x,y)) %>%
  spread(condition, probit) %>%
  group_by(r,b,theta1) %>%
  nest() %>%
  mutate(expt = 1:n()) %>%
  unnest() %>%
  group_by(expt, question, r, b, theta1, theta2) %>%
  nest() %>%
  spread(question,data) %>%
  mutate(fit = map2_dbl(x,y, mr2_sse),
         fit = if_else(fit < 1e-5,0,fit)) %>%
  mutate(theta1 = round(theta1, digits = 2)) 
# %>%
#   mutate(data = map2(x,y, ~ rbind(.x ,.y ) %>%
#                        mutate(question = c("x","y")) %>%
#                        gather(condition,probit, c("one","two","three"))))

  
d %>%  
  ggplot(aes(x=b, y=r, fill = fit, z = fit)) +
  geom_raster() +
  coord_fixed() +
  # scale_fill_gradient( )+
  geom_contour(color = "white", aes(alpha = ..level..), size = 1, binwidth = .2) +
  # geom_contour(color = "white", bins = 10) +
  facet_wrap(~theta1, labeller = "label_both") 
# +
#   scale_alpha_discrete(range = c())

```

Note that, in the bottom plots where there are contours below the diagonal, this corresponds to when the best fitting monotonic function has changed orders (e.g., x goes from 1 < 2 < 3 to 1 < 3 < 2). When such swaps aren't available, everythign below the diagonal is fit well with a monotonic step function.

For this, set the length of the base to 2. Then, choose theta of $\frac{\pi}{2}$. We sample from 5 levels of radius. Twice when the function is monotonic function, once when the the fit transitions, and from two levels of non-monotonicity.


```{r}
d <- gen_d(n_b = 2, n_theta = 100, n_r = 100, max_theta1 = 3 * (pi/2)) %>%
  mutate(condition = plyr::mapvalues(condition, 1:3 ,c("one","two","three"))) %>%
  gather(key = question, value = probit, c(x,y)) %>%
  spread(condition, probit) %>%
  group_by(r,b,theta1) %>%
  nest() %>%
  mutate(expt = 1:n()) %>%
  unnest() %>%
  group_by(expt, question, r, b, theta1, theta2) %>%
  nest() %>%
  spread(question,data) %>%
  mutate(fit = map2_dbl(x,y, mr2_sse),
         fit = if_else(fit < 1e-5,0,fit)) 

  
d %>%  
  ggplot(aes(x=theta1, y=r, fill = fit, z = fit)) +
  geom_raster() +
  geom_contour(color = "white", aes(alpha = ..level..), binwidth = .5) +
  facet_wrap(~b, nrow = 2)


```


```{r}

gen_d(n_b = 50, n_theta = 3, n_r = 50) %>%
  filter(condition == 1) %>%
  mutate(rat = (r*sin(theta1) / (b*sin(theta2)) ),
         dif = (r*sin(theta1)) - (b*sin(theta2)),
         theta1 = round(theta1, digits = 2)) %>%
  ggplot(aes(x=b, y=r, fill = dif, z = dif)) +
  geom_raster() +
  coord_fixed() +
  scale_fill_gradient2(low = scales::muted("blue"), high = scales::muted("red"), limits = c(-1, 1), breaks = c(-1,0,1)) +
  geom_contour(color = "white", bins = 20) +
  facet_wrap(~theta1, labeller = "label_both") 



```



```{r}

crossing(x = seq(from=-2, to = 2,length.out = 50),
         y = seq(from=-2, to = 2,length.out = 50),
         mu = seq(from = -1, to = 1, length.out = 3),
         rho = unique(d$condition_rho)) %>%
  mutate(cdf = pmap_dbl(list(x=x,y=y,rho=rho, mu=mu), function(x,y,rho,mu) mvtnorm::pmvnorm(upper = c(x,y), mean = c(0, mu), corr = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  mutate(mu = factor(mu)) %>%
  ggplot(aes(x = x, y = y, fill = cdf, z = cdf)) +
  facet_grid(mu~rho) +
  geom_raster() +
  coord_fixed() +
  geom_contour(color = "black", binwidth = 0.05, linetype = "solid") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  scale_fill_gradient2(midpoint = 0.5, low = scales::muted("orange"), high = scales::muted("green"),
                       limits = c(0,1), breaks = c(0,.5,1))

```



```{r}

crossing(x = seq(from=-4,to = 4,length.out = 50),
         y = seq(from=-4,to = 4,length.out = 50),
         mu1 = seq(from = -1, to = 1, length.out = 3),
         mu2 = seq(from = -1, to = 2, length.out = 4),
         rho = c(0, .95, -.95)) %>%
    filter((mu1 == -1 & mu2 == -1) | (mu1 == -1 & mu2 == 2) | (mu1 == 1 & mu2 == 1)) %>%
  mutate(pdf = pmap_dbl(list(x=x,y=y,rho=rho, mu1=mu1,mu2=mu2), function(x,y,rho, mu1,mu2) mvtnorm::dmvnorm(x = c(x,y), mean = c(mu1, mu2), sigma = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  mutate(mu2 = factor(mu2)) %>%
  ggplot(aes(x = x, y = y, fill = pdf, z = pdf, group = mu2, color = mu2)) +
  facet_grid(.~rho) +
  geom_raster() +
  coord_fixed() +
  geom_contour(binwidth = 0.05, linetype = "solid") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_segment(x = -1, y = -1, xend = -1, yend = 2, color = "black", size = 2) +
  geom_segment(x = -1, y = 2, xend = 1, yend = 1, color = "black", size = 2)

```

```{r}
d2 <- crossing(#p = seq(from = 0.05, to = .95, length.out = 25),
  p = c(0.25, 0.5, 0.75),
  p2 = c(0.25, 0.5, 0.75),
  mu1 = seq(from = -1, to = 1, length.out = 3),
  mu2 = seq(from = -1, to = 2, length.out = 4),
  rho = c(0, .95, -.95)) %>%
  filter((mu1 == -1 & p == 0.25 & p2 == 0.25) |
           (mu1 == -1  & p == 0.5 & p2 == 0.5) |
           (mu1 == 1  & p == 0.75 & p2 == 0.75)) %>%
  mutate(q = pmap_dbl(list(p=p,rho=rho, mu1=mu1, mu2=mu2), 
                      function(p,rho, mu1, mu2) mvtnorm::qmvnorm(p, mean = c(mu1, mu2), corr = matrix(c(1, rho, rho, 1), nrow = 2) )$quantile ),
         q2 = pmap_dbl(list(p=p2,rho=rho, mu1=mu1, mu2=mu2), 
                  function(p,rho, mu1, mu2) mvtnorm::qmvnorm(p, mean = c(mu1, mu2), corr = matrix(c(1, rho, rho, 1), nrow = 2) )$quantile )
  ) %>%
  mutate(rho = factor(rho),
         mu1 = factor(mu1),
         mu2 = factor(mu2))
```


```{r}

d2 %>%
  ggplot(aes(x = p, y = p2, color = rho)) +
  facet_grid(mu2 ~rho) +
  geom_point() +
  coord_fixed()

d2 %>%
  ggplot(aes(x = q, y = q2, color = rho, shape = mu2)) +
  facet_grid(mu2 ~ rho) +
  geom_point() +
  geom_line() +
  coord_fixed()

```


```{r}

crossing(mu1 = seq(from = -1, to = 1, length.out = 3),
         mu2 = seq(from = -1, to = 2, length.out = 4),
         rho = c(0, .95, -.95),
         x = c(.25,.5,.75),
         y = c(.25,.5,.75)) %>%
    filter((mu1 == -1 & mu2 == -1 & x == .25 & y == .25) |
             (mu1 == 0 & mu2 == 2 & x == .5 & y == .5) | 
             (mu1 == 1 & mu2 == 1 & x == .75 & y == .75)) %>%
  mutate(cdf = pmap_dbl(list(x=x,y=y,rho=rho, mu1=mu1, mu2=mu2), function(x,y,rho,mu1,mu2) mvtnorm::pmvnorm(upper = c(x,y), mean = c(mu1, mu2), corr = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  mutate(mu1 = factor(mu1),
         mu2 = factor(mu2)) %>%
  ggplot(aes(x = x, y = y, color = cdf)) +
  facet_grid(.~rho) +
  geom_point() +
  coord_fixed() +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) 


crossing(mu1 = seq(from = -1, to = 1, length.out = 3),
         mu2 = seq(from = -1, to = 2, length.out = 4),
         rho = c(0, .95, -.95),
         x = c(.25,.5,.75),
         y = c(.25,.5,.75)) %>%
    filter((mu1 == -1 & mu2 == -1 & x == .25 & y == .25) |
             (mu1 == 0 & mu2 == 2 & x == .5 & y == .5) | 
             (mu1 == 1 & mu2 == 1 & x == .75 & y == .75)) %>%
  mutate(cdf = pmap_dbl(list(x=x,y=y,rho=rho, mu1=mu1, mu2=mu2), function(x,y,rho,mu1,mu2) mvtnorm::pmvnorm(upper = c(x,y), mean = c(mu1, mu2), corr = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  mutate(mu1 = factor(mu1),
         mu2 = factor(mu2)) %>%
  ggplot(aes(x = cdf, y = sqrt(cdf))) +
  facet_grid(.~rho) +
  geom_point() +
  coord_fixed() +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) 
```




```{r}


d2 <- crossing(x = seq(from=-4,to = 4,length.out = 50),
         y = seq(from=-4,to = 4,length.out = 50),
         mu1 = seq(from = -1, to = 1, length.out = 3),
         mu2 = seq(from = -1, to = 2, length.out = 4),
         rho = c(0, .95, -.95)) %>%
    filter((mu1 == -1 & mu2 == -1 & x > -1 & y > -1) |
             (mu1 == -1 & mu2 == 2 & x < -1 & y < 2) |
             (mu1 == 1 & mu2 == 1 & x < 1 & y < 1)) %>%
  mutate(pdf = pmap_dbl(list(x=x,y=y,rho=rho, mu1=mu1,mu2=mu2), 
                        function(x,y,rho, mu1,mu2) mvtnorm::dmvnorm(x = c(x,y), mean = c(mu1, mu2), sigma = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  filter(pdf > .1) %>%
  mutate(cdf = pmap_dbl(list(x=x,y=y,rho=rho, mu1=mu1, mu2=mu2), 
                        function(x, y, rho, mu1, mu2) mvtnorm::pmvnorm(upper = c(x,y), mean = c(0, 0), corr = matrix(c(1, rho, rho, 1), nrow = 2) ) )) %>%
  mutate(mu1 = factor(mu1),
         mu2 = factor(mu2),
         rho = factor(rho))

```

```{r}

d2 %>%
  ggplot(aes(x = cdf^(3/4), y = cdf^(1/4), color = mu2)) +
  geom_point() +
  facet_wrap(~rho) +
  coord_fixed()

```

