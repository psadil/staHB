---
title: 'Model Recovery: Bivariate Probit'
author: "pss"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
params:
  data_dir: data
  expt: CFSgonogo
  model: "bivariate_probit_fixed_onec"
  flag: "dev"
  n_condition: 4
  n_trials_per_cond: 500
  n_subject: 1
  subject_scale: 0.01
  item_scale: 0.01
  subject_rho: 0
  item_rho: 0
  condition_rho: 0 
  condition1_mu: !r c(-1,-0.5,0.5,1)
  condition2_mu: !r c(-1,0.5,-0.5,1)
  chains: 3
  iter: 500
  warmup: 1000
  compile: 0
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, root.dir = devtools::package_file(), message = FALSE, warning = FALSE, fig.width = 7, fig.asp = 1, cache = FALSE, cache.path = paste0(file.path(devtools::package_file(), "output", "cache", params$model, params$flag, params$participant), .Platform$file.sep), fig.path = paste0(file.path(devtools::package_file(), "output", "figures", params$model, params$flag), .Platform$file.sep) )

devtools::load_all()

dir.model <- file.path(dir.stan_samples, params$model)
if (!dir.exists(dir.model)){
  dir.create(dir.model)
}
dir.model_flag <- file.path(dir.model, params$flag)
if (!dir.exists(dir.model_flag)){
  dir.create(dir.model_flag)
}

options(mc.cores = params$chains)
rstan::rstan_options("auto_write" = TRUE)

if (params$compile){
  rstan::stan_model(file.path(devtools::package_file(), "stan", paste0(params$model, ".stan")))
}

item_stds <- c(params$item_scale, params$item_scale)
item_Sigma <- matrix(c(1, params$item_rho, params$item_rho, 1), 2, 2) * (item_stds %*% t(item_stds))

subject_stds <- c(params$subject_scale, params$subject_scale)
subject_Sigma <- matrix(c(1, params$subject_rho, params$subject_rho, 1), 2, 2) * (subject_stds %*% t(subject_stds))

d <- crossing(condition = 1:params$n_condition,
              item = 1:params$n_trials_per_cond,
              subject = 1:params$n_subject,
              rho = params$condition_rho) %>%
  mutate(condition_mu = map(condition, ~cbind(params$condition1_mu[.x], params$condition2_mu[.x]))) %>%
  mutate(subject_mu = map(item, ~ mvtnorm::rmvnorm(1, mean = rep(0,2), sigma = subject_Sigma))) %>%
  mutate(item_mu = map(subject, ~ mvtnorm::rmvnorm(1, mean = rep(0,2), sigma = item_Sigma))) %>%
  mutate(Mu = pmap(list(condition_mu, subject_mu, item_mu, rho), function(a,b,c,d) mvtnorm::rmvnorm(1, mean = a + b + c, sigma = matrix(c(1, d, d, 1), 2, 2)) )) %>%
  mutate(evidence_x = map_dbl(Mu, ~purrr::pluck(.x, 1)),
         evidence_y = map_dbl(Mu, ~purrr::pluck(.x, 2))
         ) %>%
  mutate(y_sim = map(Mu, ~if_else(.x > 0, 1, 0))) %>%
  select(-Mu) %>%
  mutate(y1 = map_dbl(y_sim, ~purrr::pluck(.x, 1)),
         y2 = map_dbl(y_sim, ~purrr::pluck(.x, 2))
  )%>%
  mutate(condition2 = condition) %>%
  mutate(condition = factor(condition, levels = c(1,2,3,4), ordered = TRUE),
         condition2 = factor(condition2, levels = c(1,3,2,4), ordered = TRUE))

```

```{r}

d %>%
  group_by(condition, subject) %>%
  summarise(ev_x = mean(evidence_x), ev_y = mean(evidence_y),
            sd_x = sd(evidence_x), sd_y = sd(evidence_y),
            y1 = mean(y1), y2 = mean(y2))


```



```{r, plot_data}

d %>%
  ggplot(aes(x = evidence_x, y = evidence_y, color = factor(condition))) +
  geom_point() +
  stat_ellipse(type = "norm", geom = "polygon") +
  coord_cartesian() +
  coord_fixed()+
  theme(legend.position = "none")

```

```{r stan_data}

stan_data <- d %>%
  select(condition, item, y1, y2, subject) %>%
  mutate(condition = factor(condition),
         item = factor(item),
         subject = factor(subject)) %>%
  tidybayes::compose_data() %>%
  c(.,
    D = 2,
    priors = list(c(1, 2, 4, 2, 1, 2, 2)),
    y  = list(cbind(d$y1, d$y2))
  )

pars <- c("theta_log", "theta_raw", "lps",
         "Mu_unordered", "Mu_ordered",
         "subject_mu_raw", "item_mu_raw", "subject_mu", "item_mu",
         "subject_L", "item_L",
         "condition_omega")


```


```{r monotonic}

stan_data$X <- gen_X(d,"mon")
stan_data$n_orders <- dim(stan_data$X)[1]


estimated_model_mon <- sampling(readr::read_rds(file.path(devtools::package_file(), "stan", paste0(params$model, ".rds"))), 
                                data = stan_data, 
                                iter = params$warmup + params$iter,
                                warmup = params$warmup,
                                chains = params$chains
                                , pars = pars
                                , include = FALSE
                                , init_r = 0.5
                                , verbose = TRUE
)

# readr::write_rds(x=estimated_model_mon, path = file.path(devtools::package_file(), "output", "stan_samples", params$model, params$flag, "data_mon.rds"))

```


When the true effects of condition are symmetric, all monotonic orders are equally awful. The Bayesian model must choose to fit either the first or the second question well and the other poorly. Alternatively, the model can try to fit both effects equally poorly, in which case the mixing parameter will get stuck at 0.5.

This isn't ideal, but also not necessarily a problem. Basically, this implies that the 

```{r}

post <- tidybayes::gather_samples(estimated_model_mon,
                                  condition_mu_ordered[order,question,condition]) %>%
  ungroup()
theta <- tidybayes::gather_samples(estimated_model_mon,
                                   theta[order]) %>%
  ungroup() %>%
  mutate(order = factor(order))

post %>%
  mutate(condition = factor(condition)) %>%
  ggplot(aes(x=condition, y = estimate)) +
  geom_violin() +
  facet_grid(order~question, labeller = "label_both")

theta %>%
  ggplot(aes(x=order, y=estimate)) +
  geom_violin() 
```



```{r, non-monotonic}

stan_data$X <- gen_X(d,"nmon")
stan_data$n_orders <- dim(stan_data$X)[1]

estimated_model_Nmon <- sampling(readr::read_rds(file.path(devtools::package_file(), "stan", paste0(params$model, ".rds"))), 
                                 data = stan_data, 
                                 iter = params$warmup + params$iter,
                                 warmup = params$warmup,
                                 chains = params$chains
                                 , pars = pars
                                 , include = FALSE
                                 , init_r = 0.5
)

readr::write_rds(x=estimated_model_Nmon, path = file.path(devtools::package_file(), "output", "stan_samples", params$model, params$flag, "data_Nmon.rds"))

```


```{r}

post <- tidybayes::gather_samples(estimated_model_Nmon,
                                  condition_mu_ordered[order,question,condition]) %>%
  ungroup()
theta <- tidybayes::gather_samples(estimated_model_Nmon,
                                   theta[order]) %>%
  ungroup() %>%
  mutate(order = factor(order))

post %>%
  mutate(condition = factor(condition)) %>%
  ggplot(aes(x=condition, y = estimate)) +
  geom_violin() +
  facet_grid(order~question, labeller = "label_both")

theta %>%
  ggplot(aes(x=order, y=estimate)) +
  geom_violin() 
```


```{r}
library(loo)
tmp_mon <- extract_log_lik(estimated_model_mon)
tmp_Nmon <- extract_log_lik(estimated_model_Nmon)
mon_waic <- loo::waic(tmp_mon)
nmon_waic <- loo::waic(tmp_Nmon)
loo::compare(mon_waic, nmon_waic)
```


